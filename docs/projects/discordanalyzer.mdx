import Image from '@theme/IdealImage';

# Discord Chat Analyzer

[GitLab Repository](https://gitlab.com/lucanerlich/discordchatanalyzer)

The DCA operates on statically available chat log files, downloaded by the [DiscordChatExporter](https://github.com/Tyrrrz/DiscordChatExporter).

## Architecture and Output

After parsing all `.json` logs to Java Entities, separated into an array of `Channel` objects, each gets analyzed by the `Analyzer.java`.
The analyzer reads each message and tracks a multitude of information, automatically sorted by TreeMaps.

Based on the `rankingType`, the analyzer writes its data to separate files.

```java title="RankingType.java"
package analyzer.models.ranking;

public enum RankingType {
    MOST_MESSAGES,
    MOST_EMBEDS,
    MOST_ATTACHMENTS,
    TIMES_MENTIONED,
    ACCOUNT_AGE,
    MOST_COMMON_REACTION,
    AVG_WORD_COUNT
}
```

The data is aggregated and analyzed by an implementation of `Ranking.java`.

```java title="Ranking.java"
import analyzer.stats.AuthorData;
import lombok.Getter;
import lombok.Setter;

import java.util.List;

public abstract class Ranking {

    @Getter
    @Setter
    private transient List<AuthorData> authorDataList;

    public Ranking(List<AuthorData> authorDataList) {
        this.authorDataList = authorDataList;
    }

    public String getOutputFilePath() {
        return "logs/not-implemented.json";
    }
}
```

Ranking implementations

<Image img={require('/images/projects/dca/rankings.png')}/>

## Program Sequence

### Entity Models

By manually analyzing the available fields in the json logs, a separate pojo / entity file has been created for each object.
Using Lombok, the Pojos can be kept fairly small. This could be reduced even further, by implementing each entity as a [Java 17 record](https://docs.oracle.com/en/java/javase/17/language/records.html).

Each server (`Guild`) has multiple `Channels`. Each channel has `ChannelInfos` and `n` messages.

```java title='Channel.java'
import analyzer.models.DateRange;
import analyzer.models.Guild;
import analyzer.models.message.Message;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class Channel {

    private Guild guild;
    private ChannelInfo channel;
    private DateRange dateRange;
    private Message[] messages;
}
```

```java title='ChannelInfo.java'
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class ChannelInfo {
    private String id;
    private String type;
    private String categoryId;
    private String category;
    private String name;
    private String topic;
}
```

```java title="Message.java"
import analyzer.models.Author;
import analyzer.models.message.embed.Embed;
import analyzer.models.message.reaction.Reaction;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class Message {
    private String id;
    private String type;
    private String timestamp;
    private String timestampEdited;
    private String callEndedTimestamp;
    private boolean isPinned;
    private String content;
    private Author author;
    private Attachment[] attachments;
    private Embed[] embeds;
    private Reaction[] reactions;
    private Mention[] mentions;
    private Reference reference;
}
```

### Load JSON

We instantiate a Gson object and read all json log files in parallel.

```java title="Main.java"
private static List<Channel> parseJsonToChannels() {
        final Gson gson = new GsonBuilder().setDateFormat(DateFormat.FULL, DateFormat.FULL).create();

        final List<Channel> channels = new ArrayList<>();
        final List<String> logs = readLogs();

        logs.parallelStream().forEach(logFilePath -> {
            try (Reader reader = Files.newBufferedReader(Paths.get(logFilePath))) {
                final Channel channel = gson.fromJson(reader, Channel.class);
                channels.add(channel);
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        });

        return channels;
    }
```

### Data Aggregation

The loaded log data gets send through multiple methods of data aggregation and preparation. For each single author / chatter found.

```java title="populateAuthorDataMap()"
private void populateAuthorDataMap(AuthorData authorData, Message message) {
        analyzeMessage(authorData, message);
        authorData.setAuthorId(message.getAuthor().getId());
        authorData.setAuthor(message.getAuthor());
        authorData.setEarliestLocalDate(message.getTimestamp());
        authorDataMap.put(message.getAuthor(), authorData);
}
```

```java title="analyzeMessage()"
private void analyzeMessage(AuthorData authorData, Message message) {
        authorData.incrementMessages();
        analyzeContent(authorData, message);
        analyzeEmbeds(authorData, message);
        analyzeAttachments(authorData, message);
        analyzeMentions(authorData, message);
        analyzeReactions(authorData, message.getReactions());
}
```

The `analyzeMentions` method for example counts the amount of times, the `current` chatter has been mentioned (e.g. `@UserXYZ`).

```java title="analyzeMentions()"
private void analyzeMentions(AuthorData authorData, Message message) {
        final Mention[] mentions = message.getMentions();
        if (mentions != null && mentions.length > 0) {
            authorData.incrementTimesMentioned();
        }
}
```

Each Author collects its own data, which get updated during the analyzation process.

```java title="AuthorData.java"
@Getter
@Setter
public class AuthorData {

    private transient Author author;
    private transient LocalDate earliestLocalDate;
    private transient List<Integer> wordsPerMessage = new ArrayList<>();

    private String authorId;
    private String firstMessageSent;
    private double averageWordsPerMessage;
    private long messagesSent = 0;
    private long embedsSent = 0;
    private long attachmentsSent = 0;
    private long sumEmojisReceived = 0;
    private long timesMentioned = 0;
    private Map<Emoji, Integer> emojisReceived = new TreeMap<>(new Emoji.EmojiComparator());

// [...]
}
```

## Statistics Generation

Each data entry gets fed to a Java TreeMap which integrates a custom comparator.
The TreeMap is then automatically sorted according to the compare method written.
After all data has been ingested, the resulting TreeMap is already in the correct ranked order.

For example, the author, who has been mentioned the most, is on index 0.

```java title="Analyzer.java"
@Nullable
    public Ranking getRanking(RankingType rankingType) {
        Ranking result = null;

        switch (rankingType) {
            // [...]
            case TIMES_MENTIONED:
                result = new TimesMentionedRanking(new LinkedList<>(authorDataMap.values()));
                break;
        }

        return result;
    }
```

```java title="calculateMentionRanking()"
private void calculateMentionRanking(List<AuthorData> authorDataList) {
        timesMentioned = new TreeMap<>(new AuthorData.AuthorDataMentionsCountComparator());
        authorDataList.forEach(authorData -> timesMentioned.put(authorData, authorData.getTimesMentioned()));
}
```

## UML

*Zoom in to read*

<Image img={require('/images/projects/dca/uml.png')}/>

[Download UML Image](/images/projects/dca/uml.png)
